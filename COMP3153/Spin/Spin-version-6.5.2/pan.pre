# 1 "lights_v3.pml"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 414 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "lights_v3.pml" 2
mtype = { RED, GREEN, AMBER };

int Cars[2] = { 0, 0 };
mtype LStates[2] = RED;

int Peds[2] = { 0, 0 };
mtype PStates[2] = RED;




bool lock = false;
inline AquireLock()
{
  bool tmp = false;
  do
  :: atomic
  {
    tmp = lock;
    lock = true;
  } ->
    if
      :: tmp;
      :: else -> break;
    fi;
  od;
}

inline ReleaseLock()
{
  lock = false;
}



inline DecrementCar(i, n)
{
  if
  :: Cars[i] < n -> Cars[i] = n;
  :: else -> Cars[i] = Cars[i] - n;
  fi;
}

inline DecrementPed(i, n)
{
  if
  :: Peds[i] < n -> Peds[i] = n;
  :: else -> Peds[i] = Peds[i] - n;
  fi;
}



proctype Signal(int chance)
{

  int light = 0
car_start:
  if
  :: light = 1
  :: light = 0
  fi;


  if
  :: atomic { Cars[light]++ };
  :: atomic { Peds[light]++ }
  fi;

  goto car_start;
}

proctype TrafficLight(int this)
{
  int counter = 0;
  int other = (this + 1) % 2;

t_start:


  if

  :: atomic
  {
    LStates[this] == RED &&
    LStates[other] == RED &&
    Cars[this] > 0 &&
    PStates[other] == RED ->
    printf("L%d->Green\n", this);
    LStates[this] = GREEN;
    counter = 5;
  };


  :: atomic
  {
    LStates[this] == GREEN &&
    Cars[other] == 0 &&
    counter == 5 ->
    printf("L%d-GreenInf\n", this);
    DecrementCar(this, 1);
  };
  :: atomic
  {
    LStates[this] == GREEN &&
    counter > 0 ->
    printf("L%d-Green%d\n", this, counter);
    counter = counter - 1;
    DecrementCar(this, 1);
  };
  :: atomic
  {
    LStates[this] == GREEN &&
    counter == 0 ->
    printf("L%d->Amber\n", this);
    counter = 3;
    LStates[this] = AMBER;
    DecrementCar(this, 1);
  };
  :: atomic
  {
    LStates[this] == AMBER &&
    counter > 0 ->
    printf("L%d-Amber%d\n", this, counter);
    counter = counter - 1;
    DecrementCar(this, 1);
  };
  :: atomic
  {
    LStates[this] == AMBER &&
    counter == 0 ->
    printf("L%d->Red\n", this);
    counter = 3;
    LStates[this] = RED;
    DecrementCar(this, 1);
  };
  :: else -> skip;
  fi;

  goto t_start;
}

proctype PedestrianLight(int this)
{
  int counter = 0;
  int other = (this + 1) % 2;

p_start:



  if

  :: atomic
  {
    PStates[this] == RED &&
    LStates[other] == RED &&
    Peds[this] > 0 ->
    printf("P%d->Green\n", this);
    PStates[this] = GREEN;
    counter = 5;
  };


  :: atomic
  {
    PStates[this] == GREEN &&
    counter > 0 ->
    printf("P%d-Green%d\n", this, counter);
    counter--;
    DecrementPed(this, 1);
  };
  :: atomic
  {
    PStates[this] == GREEN &&
    counter <= 0 ->
    printf("P%d->Red\n", this);
    PStates[this] = RED;
    DecrementPed(this, 1);
  };
  :: else -> skip;
  fi;


  goto p_start;
}


proctype Safety() {
  do

  :: assert(!(LStates[0] == GREEN && LStates[1] == GREEN));
  :: assert(!(LStates[0] == AMBER && LStates[1] == AMBER));
  :: assert(!(LStates[0] == AMBER && LStates[1] == GREEN));
  :: assert(!(LStates[0] == GREEN && LStates[1] == AMBER));


  :: assert(!(PStates[0] == GREEN && LStates[1] == GREEN));
  :: assert(!(PStates[1] == GREEN && LStates[0] == GREEN));
  od
}

never {
T1_init :
 if
 :: (1) -> goto T1_init
 :: (Cars[0] > 0) -> goto T0_S2
 fi;
T0_S2 :
 if
 :: (1) -> goto T0_S2
 :: (!(Cars[0] > 0)) -> goto accept_all
 fi;
accept_all :
 skip
}

init {

  run TrafficLight(0);
  run TrafficLight(1);

  run PedestrianLight(0);
  run PedestrianLight(1);

  run Signal(40);


  run Safety();
};
